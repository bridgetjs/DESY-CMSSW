// -*- C++ -*-
//
// Package:    DemoAnalyzer
// Class:      DemoAnalyzer
// 
/**\class DemoAnalyzer DemoAnalyzer.cc Demo/DemoAnalyzer/src/DemoAnalyzer.cc

 Description: [one line class summary]

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  
//         Created:  Mon May  4 15:24:13 CEST 2015
// $Id$
// ..
//

// *** UNDER CONSTRUCTION ! ***
// *** not (yet) for public use ! *** 

// ***************************************************************************
// version of DEMO setup provided by CMS open data access team               *
// expanded/upgraded to contain validation examples for                      *
// - general reference distributions (also technical)                        *
// - minumum bias track multiplicities and pt/eta distributions (QCD-10-006) *
// - J/psi mass peak (BPH-10-002)                                            *
// - dimuon mass spectrum (MUO-10-004)                                       *
// - Z mass peak (EWK-10-)                                                   *
// - inelastic proton-proton cross section (FWD-11-001)                      *
//                                                                           *
//                         I.Dutta and A.Geiser, 30.6.15                     *
// ***************************************************************************

// system include files
#include <memory>
// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"


//------ ADD EXTRA HEADER FILES--------------------//
#include"math.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/ESHandle.h"
//#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "DataFormats/Common/interface/Ref.h"
// for histogramming
#include "TH1.h"
#include "TH3.h"
#include "TH2.h"
// for tracking information
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/TrackReco/interface/TrackFwd.h"
#include "DataFormats/TrackReco/interface/HitPattern.h"
// for vertex information 
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
// for muon information
#include "DataFormats/MuonReco/interface/Muon.h"
#include "DataFormats/MuonReco/interface/MuonFwd.h"
#include "DataFormats/MuonReco/interface/MuonSelectors.h"
#include "DataFormats/MuonReco/interface/MuonIsolation.h"
//for beamspot information
#include "DataFormats/BeamSpot/interface/BeamSpot.h"
//for electron informaton
#include "DataFormats/EgammaCandidates/interface/GsfElectron.h"
#include "DataFormats/GsfTrackReco/interface/GsfTrack.h"

//for MET informaton

#include "DataFormats/METReco/interface/PFMET.h"
#include "DataFormats/METReco/interface/PFMETFwd.h"
#include "DataFormats/METReco/interface/CaloMET.h"
#include "DataFormats/METReco/interface/CaloMETFwd.h"
#include "DataFormats/METReco/interface/MET.h"
#include "DataFormats/METReco/interface/METFwd.h"


// class declaration
//

class DemoAnalyzer : public edm::EDAnalyzer {
   public:
      explicit DemoAnalyzer(const edm::ParameterSet&);
      ~DemoAnalyzer();

  // declare variables
  double deltaz;
  double firstz;






    



   private:
      virtual void beginJob() ;
      virtual void analyze(const edm::Event&, const edm::EventSetup&);
      virtual void endJob() ;

      // ----------member data ---------------------------

// declare histograms

  TH1D *h1;
  TH1D *h2;
  TH1D *h3;
  TH1D *h4;
  TH1D *h5;
  TH1D *h6;
  TH1D *h7;
  TH1D *h8;
  TH1D *h9;
  TH1D *h10;
  TH1D *h11;
  TH1D *h12;
  TH1D *h13;
  TH1D *h14;
  TH1D *h15;
  TH1D *h16;
  TH1D *h17;
  TH1D *h18;
  TH1D *h19;
  TH1D *h20;
  TH1D *h21;
  TH1D *h22;
  // TH1D *h23;
  // TH1D *h24;
  // TH1D *h25;
  TH1D *h26;
  TH1D *h27;
  TH1D *h28;
  TH1D *h29;
  TH1D *h30;
  TH1D *h31;
  TH1D *h32;
  TH1D *h33;
  TH1D *h34;
  TH1D *h35;
  TH1D *h36;
  TH1D *h37;
  TH1D *h38;
  TH1D *h39;
  TH1D *h40;
  TH1D *h41;
  TH1D *h42;
  TH1D *h43;
  TH1D *h44;
  TH1D *h45;
  TH1D *h46;
  TH1D *h47;
  TH1D *h48;
  TH1D *h49;
  TH1D *h50;
  TH1D *h51;
  TH1D *h52;
  TH1D *h53;
  TH1D *h54;
  TH1D *h55;
  TH1D *h56;
  TH1D *h57;
  TH1D *h58;
  TH1D *h59;
  TH1D *h60;
  TH1D *h61;
  TH1D *h62;
  TH1D *h63;
  TH1D *h64;
  TH1D *h65;
  TH1D *h66;
  TH1D *h67;
  TH1D *h68;
  TH1D *h69;
  TH1D *h70;
  TH1D *h71;
  TH1D *h72;
  TH1D *h73;
  TH1D *h74;
  TH1D *h75;
  TH1D *h76;
  TH1D *h77;
  TH1D *h78;
  TH1D *h79;
  TH1D *h80;
  TH1D *h81;
  TH1D *h82;
  TH1D *h83;
  TH1D *h84;
  TH1D *h85;
  TH1D *h86;
  TH1D *h87;
  TH1D *h88;
  TH1D *h89;
  TH1D *h90;
  TH1D *h91;
  TH1D *h92;
  TH1D *h93;
  TH1D *h94;
  TH1D *h95;
  TH1D *h96;
  TH1D *h97;
  TH1D *h98;
  TH1D *h99;
  TH1D *h104;
  TH1D *h105;
  TH1D *h100;
  TH1D *h101;
  TH1D *h102;
  TH1D *h103;
  TH1D *h106;
  TH1D *h107;
  TH1D *h108;
  TH1D *h109;
  TH1D *h110;
  TH1D *h111;
  TH1D *h112;
  TH1D *h113;
  TH1D *h114;
  TH1D *h115;
  TH1D *h116;
  TH1D *h117;
  TH1D *h118;
  TH1D *h119;
  TH1D *h120;
  TH1D *h121;
  TH1D *h122;
  TH1D *h123;
  TH1D *h124;
  TH1D *h125;
  TH1D *h126;
  TH1D *h127;
  TH1D *h128;
  TH1D *h129;
  TH1D *h130;
  TH1D *h131;
  TH1D *h132;
  TH1D *h133;
  TH1D *h134;
  TH1D *h135;
  TH1D *h136;
  TH1D *h137;
  TH1D *h138;
  TH1D *h139;
  

  TH1D *h200;
  TH1D *h201;
  TH1D *h202;
  TH1D *h203; 
  TH1D *h204; 


  TH2D *h_Py;
  TH1D *h210;
};

//
// constants, enums and typedefs
// 
double s1,s2,s,scorr,s3,s4,pz,rap,w,M;
double sqm1 = pow(0.105658,2);
     //(0.105658)*(0.105658);
   double jpsim=3.097;
//
// static data member definitions
//

//
// constructors and destructor
//
DemoAnalyzer::DemoAnalyzer(const edm::ParameterSet& iConfig)

{
   //now do what ever initialization is needed
  edm::Service<TFileService> fs;


// book histograms

  //-------------------------Minimum Bias---------------------------------//

  h6 = fs->make<TH1D>("tracks" , "Tracks" , 300 , 0 , 300 ); // Track Multiplicity

  h34= fs->make<TH1D>("momentum", "Momentum",200, 0,20.0); // Track momentum
  h35= fs->make<TH1D>("pt", "PT",200, 0,4.0); //Track pt
  h36= fs->make<TH1D>("posx", "Position X",100, 0.0,.2); // Track position x
  h37= fs->make<TH1D>("posy", "Position Y",100, -.1,.1);// track position y
  h7 = fs->make<TH1D>("posz", "Position Z",100, -25.0,25.0); // Track position z
  h38= fs->make<TH1D>("eta", "Eta",100, -3.5,3.5); //Track eta
  h81= fs->make<TH1D>("track_phi", "Track_Phi",314, -3.15,3.15); //Track phi
  h8 = fs->make<TH1D>("propvertex" , "ProperVertices" , 20 , 0 , 20 ); // Proper vertices, i.e.after checking the number of tracks for the vertex
  h9 = fs->make<TH1D>("0.2pt" , "0.2pt" , 100 , 0 , 4.0 );// Tracks with absolute value of eta less than 0.2
  h10= fs->make<TH1D>("0.4pt" , "0.4pt" , 100 , 0 , 4.0 );//Tracks with absolute value mof eta between 0.2 and 0.4
  h11= fs->make<TH1D>("0.6pt" , "0.6pt" , 100 , 0 , 4.0 );// and so on...
  h12= fs->make<TH1D>("0.8pt" , "0.8pt" , 100 , 0 , 4.0 );
  h13= fs->make<TH1D>("1.0pt" , "1.0pt" , 100 , 0 , 4.0 );
  h14= fs->make<TH1D>("1.2pt" , "1.2pt" , 100 , 0 , 4.0 );
  h15= fs->make<TH1D>("1.4pt" , "1.4pt" , 100 , 0 , 4.0 );
  h16= fs->make<TH1D>("1.6pt" , "1.6pt" , 100 , 0 , 4.0 );
  h17= fs->make<TH1D>("1.8pt" , "1.8pt" , 100 , 0 , 4.0 );
  h18= fs->make<TH1D>("2.0pt" , "2.0pt" , 100 , 0 , 4.0 );
  h19= fs->make<TH1D>("2.2pt" , "2.2pt" , 100 , 0 , 4.0 );
  h20= fs->make<TH1D>("2.4pt" , "2.4pt" , 100 , 0 , 4.0 );
  h21= fs->make<TH1D>("2.6pt" , "2.6pt" , 100 , 0 , 4.0 );
  h22= fs->make<TH1D>("deltaz" , "DeltaZ" , 300 , 0 , 30.0 );// the absolute value of the distance in the z coordinate of all vertices from Primvertex->begin()
//h23=fs->make<TH1D>("track_vertex_x" , "TrackVertexX" , 100 , -30.0 , 30.0 );
//h24=fs->make<TH1D>("track_vertex_y" , "TrackVertexY" , 100 , -30.0 , 30.0 );
//h25=fs->make<TH1D>("track_vertex_z" , "TrackVertexZ" , 100 , -30.0 , 30.0 );
  h26= fs->make<TH1D>("vertex" , "Vertices" , 20 , 0 , 20 ); // Just vertex multiplicity, without any corrections

  h27= fs->make<TH1D>("VertexTrack_pt", "Vertex.Track_Pt",200,0,4.0); // Pt of tracks associated with a particular vertex
  h28= fs->make<TH1D>("VertexTrack_momentum", "VertexTrack_Momentum",200, 0,20.0); // Track momentum
  h82= fs->make<TH1D>("Vertex.Track_phi", "Vertex.Track_Phi",100, -3.5,3.5); //Track phi
  // set axis labels

h34->GetXaxis()->SetTitle("Momentum (in GeV/c)");
h34->GetYaxis()->SetTitle("Number of Events");

h35->GetXaxis()->SetTitle("Transverse Momentum (in GeV/c)");
h35->GetYaxis()->SetTitle("Number of Events");

h36->GetXaxis()->SetTitle("Position X of Vertices (in cm)");
h36->GetYaxis()->SetTitle("Number of Events");

h37->GetXaxis()->SetTitle("Position Y of Vertices (in cm)");
h37->GetYaxis()->SetTitle("Number of Events");

h7->GetXaxis()->SetTitle("Position z of Vertices (in cm)");
h7->GetYaxis()->SetTitle("Number of Events");

h38->GetXaxis()->SetTitle("Eta (in radians)");
h38->GetYaxis()->SetTitle("Number of Events");

h8->GetXaxis()->SetTitle("Number of vertices with a non zero number of tracks associated to it");
h8->GetYaxis()->SetTitle("Number of Events");

h9->GetXaxis()->SetTitle("Transverse Momentum for |eta|<0.2(in GeV/c)");
h9->GetYaxis()->SetTitle("Number of Events");

h10->GetXaxis()->SetTitle("Transverse Momentum for |eta|<0.4 and |eta|>=0.2(in GeV/c)");
h10->GetYaxis()->SetTitle("Number of Events");

h11->GetXaxis()->SetTitle("Transverse Momentum for |eta|<0.6 and |eta|>=0.4(in GeV/c)");
h11->GetYaxis()->SetTitle("Number of Events");

h12->GetXaxis()->SetTitle("Transverse Momentum for |eta|<0.8 and |eta|>=0.6(in GeV/c)");
h12->GetYaxis()->SetTitle("Number of Events");

h13->GetXaxis()->SetTitle("Transverse Momentum for |eta|<1.0 and |eta|>=0.8(in GeV/c)");
h13->GetYaxis()->SetTitle("Number of Events");

h14->GetXaxis()->SetTitle("Transverse Momentum for |eta|<1.2 and |eta|>=1.0(in Gev/c)");
h14->GetYaxis()->SetTitle("Number of Events");

h15->GetXaxis()->SetTitle("Transverse Momentum for |eta|<1.4 and |eta|>=1.2(in GeV/c)");
h15->GetYaxis()->SetTitle("Number of Events");

h16->GetXaxis()->SetTitle("Transverse Momentum for |eta|<1.6 and |eta|>=1.4(in GeV/c)");
h16->GetYaxis()->SetTitle("Number of Events");

h17->GetXaxis()->SetTitle("Transverse Momentum for |eta|<1.8 and |eta|>=1.6(in Gev/c)");
h17->GetYaxis()->SetTitle("Number of Events");

h18->GetXaxis()->SetTitle("Transverse Momentum for |eta|<2.0 and |eta|>=1.8(in GeV/c)");
h18->GetYaxis()->SetTitle("Number of Events");

h19->GetXaxis()->SetTitle("Transverse Momentum for |eta|<2.2 and |eta|>=2.0(in Gev/c)");
h19->GetYaxis()->SetTitle("Number of Events");

h20->GetXaxis()->SetTitle("Transverse Momentum for |eta|<2.4 and |eta|>=2.2(in GeV/c)");
h20->GetYaxis()->SetTitle("Number of Events");

h21->GetXaxis()->SetTitle("Transverse Momentum for |eta|<2.6 and |eta|>=2.4(in GeV/c)");
h21->GetYaxis()->SetTitle("Number of Events");

h22->GetXaxis()->SetTitle("Absolute value of the z distance of Vertices from the first primary vertex (in cm)");
h22->GetYaxis()->SetTitle("Number of Events");

h26->GetXaxis()->SetTitle("Vertex multiplicity");
h26->GetYaxis()->SetTitle("Number of Events");

h28->GetXaxis()->SetTitle("Momentum of tracks associated with a vertex (in GeV/c)");
h28->GetYaxis()->SetTitle("Number of Events");

h27->GetXaxis()->SetTitle("Transverse Momentum of tracks associated with a vertex (in GeV/c)");
h27->GetYaxis()->SetTitle("Number of Events");


 //------------------------------Muons and Onia--------------------------------------//
 // use either global muons from inclusive Mu sample 
 // or tracker muons from Onia sample (preselected 2.5<m<4.1 GeV) 


h1 = fs->make<TH1D>("GMmomentum" , "GM_Momentum" , 240 , 0. , 120. );//TrackCollection_GMuon momentum
h2 = fs->make<TH1D>("GM_Transverse_momentum" , "TransverseMomentum" , 240 , 0. , 120. );//TrackCollection_GMuon Transverse_momentum
h3 = fs->make<TH1D>("GM_eta" , "GM_Eta" , 140 ,-3.5 , 3.5 );//TrackColletion_GMuon eta
h83=fs->make<TH1D>("GM_phi", "GM_phi",314, -3.15,3.15);
h4 = fs->make<TH1D>("GMmultiplicty" , "GMmultiplicity" , 8 , 0 , 8 );//TrackCollection_GMuon multiplicity
h5 = fs->make<TH1D>("GMmass" , "GMmass" ,120 , 0. , 12. );//TrackCollection_GMuon mas
h44= fs->make<TH1D>("GMmass_extended" , "GMmass" ,120 , 0. , 120. );//TrackCollection_GMuon mass
h29= fs->make<TH1D>("Muon_momentum" , "Muon_momentum" ,100 , 0. , 20. );//MuonCollection_ momentum
h30= fs->make<TH1D>("Muon_pt" , "Muon_PT" ,100 , 0. , 20. );//MuonCollection_pt
h31= fs->make<TH1D>("Muon_eta" , "Muon_eta" ,140 , -3.5 , 3.5 );//MuonCollection_ eta
h84= fs->make<TH1D>("Muon_phi", "Muon_phi",314, -3.15,3.15);
h32= fs->make<TH1D>("TM_mass" , "TM_mass" ,120 , 0. , 12. );//MuonCollection_TMuon mass
h33= fs->make<TH1D>("NMuons" , "Muon_Size" ,10 , 0. ,10  );//MuonCollection_Muon size

h39= fs->make<TH1D>("TM_mass1.2_j_psi" , "TM_mass" ,90 ,2.6  , 3.5 );//MuonCollection_TMuon mass_j/psi
h40= fs->make<TH1D>("TM_mass1.6_j_psi" , "TM_mass" ,90 , 2.6 , 3.5 );//MuonCollection_TMuon mass_j/psi
h41= fs->make<TH1D>("TM_mass2.4_j_psi" , "TM_mass" ,90 ,2.6 , 3.5 );//MuonCollection_TMuon mass_j/psi

h42= fs->make<TH1D>("TM_mass1_upsilon" , "TM_mass" ,80 ,8.  , 12. );//MuonCollection_TMuon mass_upsilon

h43= fs->make<TH1D>("TM_mass2.4_upsilon" , "TM_mass" ,80 ,8. ,12. );//MuonCollection_TMuon mass_ upsilon
h45= fs->make<TH1D>("TM_mass_likeCharges" , "TM_mass_Like Charges" ,120 , 0. , 12. );//MuonCollection_TMuon mass_ FOR LIKE CHARGES
h46= fs->make<TH1D>("GM_mass_likeCharges" , "GM_mass_Like Charges" ,120 , 0. , 12. );//TrackCollection_GMuon mass_ FOR LIKE CHARGES


h47= fs->make<TH1D>("GM_mass1.2_j_psi" , "GM_mass" ,90 ,2.6  , 3.5 );//TrackCollection_GMuon mass_j/psi
h48= fs->make<TH1D>("GM_mass1.6_j_psi" , "GM_mass" ,90 , 2.6 , 3.5 );//TrackCollection_GMuon mass_j/psi
h49= fs->make<TH1D>("GM_mass2.4_j_psi" , "GM_mass" ,90 ,2.6 , 3.5 );//TrackCollection_gMuon mass_j/psi

h50= fs->make<TH1D>("TM_chi2" , "TM_Chi2" ,500 ,0 , 100 );//MuonCollection
h51= fs->make<TH1D>("TM_Ndof" , "TM_Ndof" ,60 ,0 , 60 );//MuonCollection
h52= fs->make<TH1D>("TM_NormalizedChi2" , "TM_NormalizedChi2" ,200 ,0 , 20 );//MuonCollection

h53= fs->make<TH1D>("GM_chi2" , "GM_Chi2" ,300 ,0 , 150 );//TrackCollection
h54= fs->make<TH1D>("GM_ndof" , "GM_ndof" ,100 ,0 , 100 );//TrackCollection
h55= fs->make<TH1D>("GM_normalizedchi2" , "GM_normalizedChi2" ,200 ,0 , 20 );//TrackCollection

h56= fs->make<TH1D>("Muon_chi2" , "Muon_Chi2" ,500 ,0 , 100 );//MuonCollection
h57= fs->make<TH1D>("Muon_Ndof" , "Muon_Ndof" ,60 ,0 , 60 );//MuonCollection
h58= fs->make<TH1D>("Muon_NormalizedChi2" , "Muon_NormalizedChi2" ,200 ,0 , 20 );//MuonCollection

h59= fs->make<TH1D>("GM_HitsOK" , "GM_Tracks with good Hits" ,10 ,0 , 10 );//TrackCollection

h60= fs->make<TH1D>("GM_validhits" , "GM_ValidHits" ,100, 0. ,100 );//TrackCollection
h61= fs->make<TH1D>("GM_pixelhits" , "GM_pixelhits" ,14 , 0. ,14 );//TrackCollection

h62= fs->make<TH1D>("TM_HitsOK" , "TM_Tracks with good Hits" ,10 ,0 , 10 );//MuonCollection

h63= fs->make<TH1D>("TM_validhits" , "TM_ValidHits" ,40, 0. ,40 );//MuonCollection
h64= fs->make<TH1D>("TM_pixelhits" , "TM_pixelhits" ,14 , 0. ,14 );//MuonCollection


h65= fs->make<TH1D>("TM_mass_C" , "TM_mass" ,120 , 0. , 12. );//MuonCollection_TMuon mass_corrected
h66= fs->make<TH1D>("GMmass_C" , "GMmass" ,120 , 0. , 12. );//TrackCollection_GMuon mass_corrected
h67= fs->make<TH1D>("GMmass_extended_C" , "GMmass" ,120 , 0. , 120. );//TrackCollection_GMuon mass_corrected

h68= fs->make<TH1D>("GM_mass1.2_j_psi_C" , "GM_mass" ,90 ,2.6  , 3.5 );//TrackCollection_GMuon mass_j/psi
h69= fs->make<TH1D>("GM_mass1.6_j_psi_C" , "GM_mass" ,90 , 2.6 , 3.5 );//TrackCollection_GMuon mass_j/psi
h70= fs->make<TH1D>("GM_mass2.4_j_psi_C" , "GM_mass" ,90 ,2.6 , 3.5 );//TrackCollection_gMuon mass_j/psi

h71= fs->make<TH1D>("TM_mass1_upsilon_C" , "TM_mass" ,80 ,8.  , 12. );//MuonCollection_TMuon mass_upsilon

h72= fs->make<TH1D>("TM_mass2.4_upsilon_C" , "TM_mass" ,80 ,8. ,12. );//MuonCollection_TMuon mass_ upsilon


h73= fs->make<TH1D>("TM_mass1.2_j_psi_C" , "TM_mass" ,90 ,2.6  , 3.5 );//MuonCollection_TMuon mass_j/psi
h74= fs->make<TH1D>("TM_mass1.6_j_psi_C" , "TM_mass" ,90 , 2.6 , 3.5 );//MuonCollection_TMuon mass_j/psi
h75= fs->make<TH1D>("TM_mass2.4_j_psi_C" , "TM_mass" ,90 ,2.6 , 3.5 );//MuonCollection_TMuon mass_j/psi

h76= fs->make<TH1D>("GM_mass1_upsilon" , "GM_mass" ,80 ,8.  , 12. );//TrackCollection_TMuon mass_upsilon

h77= fs->make<TH1D>("GM_mass2.4_upsilon" , "GM_mass" ,80 ,8. ,12. );//TrackCollection_TMuon mass_ upsilon

h78= fs->make<TH1D>("GM_mass1_upsilon_C" , "GM_mass" ,80 ,8.  , 12. );//TrackCollection_TMuon mass_upsilon

h79= fs->make<TH1D>("GM_mass2.4_upsilon_C" , "GM_mass" ,80 ,8. ,12. );//TrackCollection_TMuon mass_ upsilon

h80=fs->make<TH1D>("GM_Zmass", "GM_Zmass",30, 60.0,120.0); 
h94=fs->make<TH1D>("GM_Zmass_cuts", "GM_Zmass_cuts",30, 60.0,120.0); 

h95=fs->make<TH1D>("GM_Zmass_cuts_like_charges", "GM_Zmass_cuts_like_charges",30, 60.0,120.0); 

h85= fs->make<TH1D>("eta_no_mu", "Eta_with no Muon",100, -3.5,3.5); //Track eta if Muon not found

h86= fs->make<TH1D>("tracks_per_vertex_using_counter" , "Tracks per Vertex using counter" , 200 , 0 , 200 );// Track Multiplicity
h87= fs->make<TH1D>("tracks_per_vertex" , "Tracks per Vertex" , 200 , 0 , 200 );// Track Multiplicity

h88=fs->make<TH1D>("dx_muon" , "dx_muon" , 100 , 0 , 1 );
h89=fs->make<TH1D>("dy_muon" , "dy_muon" , 100 , 0 , 1 );
h90=fs->make<TH1D>("dz_muon" , "dz_muon" , 200 , 0 , 2 );
h91=fs->make<TH1D>("dxy_Gmuon" , "dxy_gmuon" , 100 , 0 , 1 );
h92=fs->make<TH1D>("goodMuonChamberHit_Gmuon" , "goodMuonChamberHit_gmuon" , 40,0 , 40 );
h93=fs->make<TH1D>("MuonStations_Tmuon" , "MuonStations_Tmuon" , 2,0 , 2 );

h96= fs->make<TH1D>("Electron_momentum" , "Electron_momentum" ,400 , 0. , 200. );//ElectronCollection_ momentum
h97= fs->make<TH1D>("Electron_pt" , "Electron_PT" ,400 , 0. , 200. );//ElectronCollection_pt
h98= fs->make<TH1D>("Electron_eta" , "Electron_eta" ,140 , -3.5 , 3.5 );//ElectronCollection_ eta
h99= fs->make<TH1D>("Electron_phi", "Electron_phi",314, -3.17,3.17);
h104= fs->make<TH1D>("Z_electron_mass" , "electron_mass" ,30 , 60. , 120. );//ElectronCollection mass
h105= fs->make<TH1D>("Nelectrons" , "Electron_Size" ,10 , 0. ,10  );//ElectronCollection_Muon size
h106= fs->make<TH1D>("Super Cluster_eta" , "Super Cluster_eta" ,140 , 0 , 3.5 );//Electron super cluster_ eta
h107= fs->make<TH1D>("Super Cluster_rawenergy" , "Super Cluster_rawenergy" ,200 , 0 , 200 );//Electron super cluster_ energy
h118= fs->make<TH1D>("Electron Et" , "Electron Et" ,200 , 0 , 200 );//Electron et

h119= fs->make<TH1D>("Z_electron_mass_cuts" , "electron_mass_cuts" ,30 , 60. , 120. );//ElectronCollection mass
h108= fs->make<TH1D>("Barrel_Electron_track isolation" , "Barrel_Electron Track Isolation" ,500 , 0. , 0.5 );
h109= fs->make<TH1D>("Barrel_Electron_Ecal isolation" , "Barrel_Electron ECAL Isolation" ,500 , 0. ,0.5 );
h110= fs->make<TH1D>("Barrel_Electron_hcal isolation" , "Barrel_Electron HCAL Isolation" ,500 , 0. ,0.5 );
h111= fs->make<TH1D>("Electron_track missing hit" , "Electron Track missing hits" ,5 , 0. ,5);
h112= fs->make<TH1D>("Electron_Dcot" , "Electron Dcot" ,1000 , -0.05 ,0.05);
h113= fs->make<TH1D>("Electron_Dist" , "Electron Dist" ,1000 , -0.05 ,0.05);
h114= fs->make<TH1D>("Barrel_Electron_sigmaIetaIeta" , "Barrel_Electron sigmaIetaIeta" ,300 , 0. ,0.03);
h115= fs->make<TH1D>("Barrel_Electron_deltaphi" , "Barrel_Electron deltaphi" ,10000 , -0.5 ,0.5);
h116= fs->make<TH1D>("Barrel_Electron_deltaeta" , "Barrel_Electron deltaeta" ,10000 , -0.05 ,0.05);
h117= fs->make<TH1D>("Barrel_Electron_H/E" , "Barrel_Electron H/E" ,1200 , 0. ,0.2);


h120= fs->make<TH1D>("Endcap_Electron_track isolation" , "Endcap_Electron Track Isolation" ,500 , 0. , 0.5 );
h121= fs->make<TH1D>("Endcap_Electron_Ecal isolation" , "Endcap_Electron ECAL Isolation" ,500 , 0. ,0.5 );
h122= fs->make<TH1D>("Endcap_Electron_hcal isolation" , "Endcap_Electron HCAL Isolation" ,500 , 0. ,0.5 );
h123= fs->make<TH1D>("Endcap_Electron_sigmaIetaIeta" , "Endcap_Electron sigmaIetaIeta" ,1000 , 0. ,0.1);
h124= fs->make<TH1D>("Endcap_Electron_deltaphi" , "Endcap_Electron deltaphi" ,1000 , -0.5,0.5);
h125= fs->make<TH1D>("Endcap_Electron_deltaeta" , "Endcap_Electron deltaeta" ,400 , -0.01 ,0.01);
h126= fs->make<TH1D>("Endcap_Electron_H/E" , "Endcap_Electron H/E" ,1000 , 0. ,0.1);
h127= fs->make<TH1D>("Z_electron_mass_likeCharges" , "electron_mass_likeCharges" ,30 , 60. , 120. );//ElectronCollection mass
h128= fs->make<TH1D>("Z_electron_mass_cuts_likeCharges" , "electron_mass_cuts_likeCharges" ,30 , 60. , 120. );//ElectronCollection mass
h129= fs->make<TH1D>("W_muon_transverseMass" , "muon_transverseMass" ,30 , 0. , 120. );//MuonCollection mass
h130= fs->make<TH1D>("W_muon_transverseMass_cuts" , "muon_transverseMass_cuts" ,30 , 0. , 120. );//MuonCollection mass
h131= fs->make<TH1D>("W_electron_transverseMass" , "electron_transverseMass" ,30 , 0. , 120. );//ElectronCollection mass
h132= fs->make<TH1D>("W_electron_transverseMass_cuts" , "electron_transverseMass_cuts" ,30 , 0. , 120. );//ElectronCollection mass
h133= fs->make<TH1D>("Event_PFMET" , "Event_PFMET" ,28 , 0. , 70. );//ElectronCollection MET for W's
h134= fs->make<TH1D>("Event_CaloMET" , "Event_CaloMET" ,28 , 0. , 70. );//ElectronCollection MET for W's
h135= fs->make<TH1D>("muonCorrCaloMET" , "muonCorrCaloMET" ,28 , 0. , 70. );//ElectronCollection MET for W's
h136= fs->make<TH1D>("Event_PFMET_electroncuts" , "Event_PFMET" ,28 , 0. , 70. );//ElectronCollection MET for W's
h137= fs->make<TH1D>("Event_PFMET_muoncuts" , "Event_PFMET" ,28 , 0. , 70. );//ElectronCollection MET for W's
h138= fs->make<TH1D>("Electron_Z_Dcot" , "Electron Dcot" ,1000 ,-0.5 ,0.5);
h139= fs->make<TH1D>("Electron_Z_Dist" , "Electron Dist" ,1000 ,-0.5 ,0.5);





// change binning to correspond to log(0.3) - log(500), 200 bins/log10 unit
h100=fs->make<TH1D>("GM_mass_log", "GM mass log", 644, -.52, 2.7 );//TrackCollection_GMuon mass
h101=fs->make<TH1D>("TM_mass_log", "TM mass log", 644, -.52, 2.7 );//MuonCollection_TMuon mass
h102=fs->make<TH1D>("GM_mass_log_likecharges", "GM mass log like", 644, -.52, 2.7 );//TrackCollection_GMuon mass
h103=fs->make<TH1D>("TM_mass_log_likecharges", "TM mass log like", 644, -.52, 2.7 );//MuonCollection_TMuon mass


// set axis labels

h1->GetXaxis()->SetTitle("Global Muon Momentum from track collection(in GeV/c)");
h1->GetYaxis()->SetTitle("Number of Events");

h2->GetXaxis()->SetTitle("Transverse Momentum of global muons from track collection(in GeV/c)");
h2->GetYaxis()->SetTitle("Number of Events");

h3->GetXaxis()->SetTitle("Eta of global muons from track collection (in radians)");
h3->GetYaxis()->SetTitle("Number of Events");
h4->GetXaxis()->SetTitle("Number of Global Muons");
h4->GetYaxis()->SetTitle("Number of Events");

h5->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h5->GetYaxis()->SetTitle("Number of Events");

h6->GetXaxis()->SetTitle("Number of Tracks");
h6->GetYaxis()->SetTitle("Number of Events");

h29->GetXaxis()->SetTitle("Momentum (in GeV/c)");
h29->GetYaxis()->SetTitle("Number of Events");

h30->GetXaxis()->SetTitle("Transverse Momentum (in GeV/c)");
h30->GetYaxis()->SetTitle("Number of Events");

h31->GetXaxis()->SetTitle("Eta (in radians)");
h31->GetYaxis()->SetTitle("Number of Events"); 

h33->GetXaxis()->SetTitle("Number of Muons");
h33->GetYaxis()->SetTitle("Number of Events");

h39->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 with|eta|<1.2(in GeV/c^2)");
h39->GetYaxis()->SetTitle("Number of Events");

h40->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 with |eta|>1.2 and |eta|<1.6 (in GeV/c^2)");
h40->GetYaxis()->SetTitle("Number of Events");

h41->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 with |eta|>1,6 and |eta|<2.4 (in GeV/c^2)");
h41->GetYaxis()->SetTitle("Number of Events");

h32->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h32->GetYaxis()->SetTitle("Number of Events");
h44->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h44->GetYaxis()->SetTitle("Number of Events");
h42->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h42->GetYaxis()->SetTitle("Number of Events");
h43->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h43->GetYaxis()->SetTitle("Number of Events");

h45->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h45->GetYaxis()->SetTitle("Number of Events");
h46->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h46->GetYaxis()->SetTitle("Number of Events");

h47->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h47->GetYaxis()->SetTitle("Number of Events");

h48->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h48->GetYaxis()->SetTitle("Number of Events");
h49->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h49->GetYaxis()->SetTitle("Number of Events");

h50->GetXaxis()->SetTitle("Chi2 values");
h50->GetYaxis()->SetTitle("Number of Events");
h51->GetXaxis()->SetTitle("Ndof values");
h51->GetYaxis()->SetTitle("Number of Events");
h52->GetXaxis()->SetTitle("NormalizedChi2 values");
h52->GetYaxis()->SetTitle("Number of Events");

h53->GetXaxis()->SetTitle("Chi2 values");
h53->GetYaxis()->SetTitle("Number of Events");
h54->GetXaxis()->SetTitle("Ndof values");
h54->GetYaxis()->SetTitle("Number of Events");
h55->GetXaxis()->SetTitle("NormalizedChi2 values");
h55->GetYaxis()->SetTitle("Number of Events");

h56->GetXaxis()->SetTitle("Chi2 values");
h56->GetYaxis()->SetTitle("Number of Events");
h57->GetXaxis()->SetTitle("Ndof values");
h57->GetYaxis()->SetTitle("Number of Events");
h58->GetXaxis()->SetTitle("NormalizedChi2 values");
h58->GetYaxis()->SetTitle("Number of Events");

h59->GetXaxis()->SetTitle("Good Track multiplicity");
h59->GetYaxis()->SetTitle("Number of Events");

h60->GetXaxis()->SetTitle("Number of valid hits");
h60->GetYaxis()->SetTitle("Number of Events");

h61->GetXaxis()->SetTitle("Munber of pixel hits");
h61->GetYaxis()->SetTitle("Number of Events");
h62->GetXaxis()->SetTitle("Good Track multiplicity");
h62->GetYaxis()->SetTitle("Number of Events");

h63->GetXaxis()->SetTitle("Number of valid hits");
h63->GetYaxis()->SetTitle("Number of Events");

h64->GetXaxis()->SetTitle("Munber of pixel hits");
h64->GetYaxis()->SetTitle("Number of Events");

h65->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h65->GetYaxis()->SetTitle("Number of Events");

h66->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h66->GetYaxis()->SetTitle("Number of Events");

h67->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h67->GetYaxis()->SetTitle("Number of Events");

h68->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h68->GetYaxis()->SetTitle("Number of Events");

h69->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h69->GetYaxis()->SetTitle("Number of Events");
h70->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h70->GetYaxis()->SetTitle("Number of Events");
h72->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h72->GetYaxis()->SetTitle("Number of Events");
h71->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h71->GetYaxis()->SetTitle("Number of Events");

h73->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h73->GetYaxis()->SetTitle("Number of Events");

h74->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h74->GetYaxis()->SetTitle("Number of Events");
h75->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h75->GetYaxis()->SetTitle("Number of Events");

h76->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h76->GetYaxis()->SetTitle("Number of Events");
h77->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h77->GetYaxis()->SetTitle("Number of Events");
h78->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h78->GetYaxis()->SetTitle("Number of Events");
h79->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h79->GetYaxis()->SetTitle("Number of Events");
h80->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h80->GetYaxis()->SetTitle("Number of Events");

h81->GetXaxis()->SetTitle("Phi");
h81->GetYaxis()->SetTitle("Number of Events");
h82->GetXaxis()->SetTitle("Phi");
h82->GetYaxis()->SetTitle("Number of Events");
h83->GetXaxis()->SetTitle("Phi");
h83->GetYaxis()->SetTitle("Number of Events");
h84->GetXaxis()->SetTitle("Phi");
h84->GetYaxis()->SetTitle("Number of Events");

h85->GetXaxis()->SetTitle("Eta (in radians)");
h85->GetYaxis()->SetTitle("Number of Events"); 

h86->GetXaxis()->SetTitle("Number of Tracks");
h86->GetYaxis()->SetTitle("Number of Vertices");
h87->GetXaxis()->SetTitle("Number of Tracks");
h87->GetYaxis()->SetTitle("Number of Vertices");

h88->GetXaxis()->SetTitle("difference in x");
h88->GetYaxis()->SetTitle("Number of Events");
h89->GetXaxis()->SetTitle("difference in y");
h89->GetYaxis()->SetTitle("Number of Events");
h90->GetXaxis()->SetTitle("difference in z");
h90->GetYaxis()->SetTitle("Number of Events");
h91->GetXaxis()->SetTitle("Transverse impact paramemter w.r.t. BS");
h91->GetYaxis()->SetTitle("Number of Events");
h92->GetXaxis()->SetTitle("Number of valid hits");
h92->GetYaxis()->SetTitle("Number of Events");
h93->GetXaxis()->SetTitle("Muons matching with at least two muon stations");
h93->GetYaxis()->SetTitle("Number of Events");

h94->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h94->GetYaxis()->SetTitle("Number of Events");
h95->GetXaxis()->SetTitle("Invariant Mass for Nmuon>=2 (in GeV/c^2)");
h95->GetYaxis()->SetTitle("Number of Events");

h96->GetXaxis()->SetTitle("Momentum (in GeV/c)");
h96->GetYaxis()->SetTitle("Number of Events");
h97->GetXaxis()->SetTitle("Transverse Momentum (in GeV/c)");
h97->GetYaxis()->SetTitle("Number of Events");
h98->GetXaxis()->SetTitle("Eta (in radians)");
h98->GetYaxis()->SetTitle("Number of Events");
h99->GetXaxis()->SetTitle("Eta (in radians)");
h99->GetYaxis()->SetTitle("Number of Events"); 
h104->GetXaxis()->SetTitle("Invariant Mass for Nelectron>=2 (in GeV/c^2)");
h104->GetYaxis()->SetTitle("Number of Events");
h105->GetXaxis()->SetTitle("Number of Electrons");
h105->GetYaxis()->SetTitle("Number of Events");

h106->GetXaxis()->SetTitle("Super Cluster Eta(in radians)");
h106->GetYaxis()->SetTitle("Number of Events");
h107->GetXaxis()->SetTitle("Super Cluster Energy");
h107->GetYaxis()->SetTitle("Number of Events");
h108->GetXaxis()->SetTitle("Track Isolation");
h108->GetYaxis()->SetTitle("Number of Events");
h109->GetXaxis()->SetTitle("Ecal Isolation");
h109->GetYaxis()->SetTitle("Number of Events");
h110->GetXaxis()->SetTitle("Hcal Isolation");
h110->GetYaxis()->SetTitle("Number of Events");
h111->GetXaxis()->SetTitle("gsfTrack Hit type");
h111->GetYaxis()->SetTitle("Number of Events");
h112->GetXaxis()->SetTitle("Dcot");
h112->GetYaxis()->SetTitle("Number of Events");
h113->GetXaxis()->SetTitle("Dist");
h113->GetYaxis()->SetTitle("Number of Events");
h114->GetXaxis()->SetTitle("sigmaIetaIeta");
h114->GetYaxis()->SetTitle("Number of Events");
h115->GetXaxis()->SetTitle("DeltaPhi");
h115->GetYaxis()->SetTitle("Number of Events");
h116->GetXaxis()->SetTitle("DeltaEta");
h116->GetYaxis()->SetTitle("Number of Events");
h117->GetXaxis()->SetTitle("H/E");
h117->GetYaxis()->SetTitle("Number of Events");
h118->GetXaxis()->SetTitle("Electron Et");
h118->GetYaxis()->SetTitle("Number of Events");
h119->GetXaxis()->SetTitle("Invariant Mass for Nelectron>=2 (in GeV/c^2)");
h119->GetYaxis()->SetTitle("Number of Events");
h120->GetXaxis()->SetTitle("Track Isolation");
h120->GetYaxis()->SetTitle("Number of Events");
h121->GetXaxis()->SetTitle("Ecal Isolation");
h121->GetYaxis()->SetTitle("Number of Events");
h122->GetXaxis()->SetTitle("Hcal Isolation");
h122->GetYaxis()->SetTitle("Number of Events");

h123->GetXaxis()->SetTitle("sigmaIetaIeta");
h123->GetYaxis()->SetTitle("Number of Events");
h124->GetXaxis()->SetTitle("DeltaPhi");
h124->GetYaxis()->SetTitle("Number of Events");
h125->GetXaxis()->SetTitle("DeltaEta");
h125->GetYaxis()->SetTitle("Number of Events");
h126->GetXaxis()->SetTitle("H/E");
h126->GetYaxis()->SetTitle("Number of Events");
h127->GetXaxis()->SetTitle("Invariant Mass for Nelectron>=2 (in GeV/c^2)");
h127->GetYaxis()->SetTitle("Number of Events");
h128->GetXaxis()->SetTitle("Invariant Mass for Nelectron>=2 (in GeV/c^2)");
h128->GetYaxis()->SetTitle("Number of Events");

h129->GetXaxis()->SetTitle("Transverse Mass for muons+MET (in GeV/c^2)");
h129->GetYaxis()->SetTitle("Number of Events");
h130->GetXaxis()->SetTitle("Transverse Mass for muons+MET (in GeV/c^2)");
h130->GetYaxis()->SetTitle("Number of Events");
h131->GetXaxis()->SetTitle("Transverse Mass for electrons+MET (in GeV/c^2)");
h131->GetYaxis()->SetTitle("Number of Events");
h132->GetXaxis()->SetTitle("Transverse Mass for electrons+MET (in GeV/c^2)");
h132->GetYaxis()->SetTitle("Number of Events");
h133->GetXaxis()->SetTitle("MET (in GeV)");
h133->GetYaxis()->SetTitle("Number of Events");
h134->GetXaxis()->SetTitle("MET (in GeV)");
h134->GetYaxis()->SetTitle("Number of Events");
h135->GetXaxis()->SetTitle("MET (in GeV)");
h135->GetYaxis()->SetTitle("Number of Events");
h136->GetXaxis()->SetTitle("MET (in GeV)");
h136->GetYaxis()->SetTitle("Number of Events");
h137->GetXaxis()->SetTitle("MET (in GeV)");
h137->GetYaxis()->SetTitle("Number of Events");





h100->GetXaxis()->SetTitle("Invariant Log10(Mass) for Nmuon>=2 (in GeV/c^2)");
h100->GetYaxis()->SetTitle("Number of Events/GeV");
h101->GetXaxis()->SetTitle("Invariant Log10(Mass) for Nmuon>=2 (in GeV/c^2)");
h101->GetYaxis()->SetTitle("Number of Events/GeV");
h102->GetXaxis()->SetTitle("Invariant Log10(Mass) for Nmuon>=2 (in GeV/c^2)");
h102->GetYaxis()->SetTitle("Number of Events/GeV");
h103->GetXaxis()->SetTitle("Invariant Log10(Mass) for Nmuon>=2 (in GeV/c^2)");
h103->GetYaxis()->SetTitle("Number of Events/GeV");


//                event property histograms                //

// histograms to check and simulate JSON
h200=fs->make<TH1D>("Run number", "Run number", 3100, 146400, 149500);
h201=fs->make<TH1D>("Run number, no JSON", "Run number, no JSON, should be empty!", 3100, 146400, 149500);
h202=fs->make<TH1D>("Event number", "Event number", 2000, 0, 2000000000);
h203=fs->make<TH1D>("Lumi section", "Lumi section", 300, 0, 3000);
h204=fs->make<TH1D>("Run number, JSON", "Run number, JSON, should be filled", 3100, 146400, 149500);



// 2D histograms for acceptance 

 h_Py=fs->make<TH2D>("h_Py", "", 25,0, 2.4, 25, 0,30);



 //Invariant mass hist for testing function 

h210 = fs->make<TH1D>("h210" , "" ,120 , 0. , 12. );//Test histogram for mass function 
}


DemoAnalyzer::~DemoAnalyzer()
{
 
   // do anything here that needs to be done at destruction time
   // (e.g. close files, deallocate resources etc.)

}


//
// member functions
//
double invMass(double p1,double p1x, double p1y, double p1z, double p2, double p2x, double p2y, double p2z);
    

// ------------ method called for each event  ------------
void
DemoAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
   using namespace edm;
   using namespace reco;
   using namespace std;
   //using reco::TrackCollection;
   //using reco::VertexCollection;
   //using reco::MuonCollection;

Handle<reco::BeamSpot> beamSpotHandle;
Handle<reco::TrackCollection> tracks;
Handle<reco::TrackCollection> gmuons;
Handle<reco::VertexCollection> Primvertex;
Handle<reco::MuonCollection> muons;
Handle<reco::GsfElectronCollection> electrons;
 edm:: Handle<edm::View<reco::PFMET> > pfmets;// Handle<reco::PFMET> mets;  didn't work for some reason
edm:: Handle<edm::View<reco::CaloMET> > calomets;
edm:: Handle<edm::View<reco::CaloMET> > muCorrmets;

  #ifdef THIS_IS_AN_EVENT_EXAMPLE 
   Handle<ExampleData> pIn;
   iEvent.getByLabel("example",pIn);
   #endif

   // should we use this?   
   #ifdef THIS_IS_AN_EVENTSETUP_EXAMPLE
   ESHandle<SetupData> pSetup;
   iSetup.get<SetupRecord>().get(pSetup);
   #endif
 

  
   //                   fill basic event information                  //
   //    *** still under very preliminary construction   ****

   //LogInfo("Demo")<<"Event number"<<iEvent.id()<<" Run number"<<iEvent.run();
 
 h200->Fill(iEvent.run());
 h202->Fill((iEvent.id()).event());
 h203->Fill(iEvent.luminosityBlock());
 // check JSON "by hand"; according to documentation, JSON provides a
 // "list of good lumi sections"
 // if badJSON nonzero event should not be used for analysis
 int badJSON = 0;
 if (iEvent.run() == 146428) {
  if ((iEvent.luminosityBlock() > 2 && iEvent.luminosityBlock() < 11) ||
      (iEvent.luminosityBlock() > 52 && iEvent.luminosityBlock() < 55) ||
      (iEvent.luminosityBlock() > 92))
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146430) {
  if ((iEvent.luminosityBlock() > 12 && iEvent.luminosityBlock() < 18) ||
      (iEvent.luminosityBlock() > 47 && iEvent.luminosityBlock() < 50) ||
      (iEvent.luminosityBlock() > 62 && iEvent.luminosityBlock() < 65) ||
      (iEvent.luminosityBlock() > 90))
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146431) {
  if (iEvent.luminosityBlock() > 23)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146436) {
  if (iEvent.luminosityBlock() > 532)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146437) {
  if (iEvent.luminosityBlock() > 798)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146510) {
  if (iEvent.luminosityBlock() > 510)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146511) {
  if (iEvent.luminosityBlock() == 64 || iEvent.luminosityBlock() > 778)
    badJSON = iEvent.run(); 
 }
else if (iEvent.run() == 146513) {
  if (iEvent.luminosityBlock() == 2 || iEvent.luminosityBlock() > 15)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146514) {
  if (iEvent.luminosityBlock() == 546 || iEvent.luminosityBlock() == 547 || iEvent.luminosityBlock() > 871)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146589) {
  if (iEvent.luminosityBlock() < 34 || iEvent.luminosityBlock() > 248)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146644) {
   if (iEvent.luminosityBlock() < 89 || iEvent.luminosityBlock() == 118 || iEvent.luminosityBlock() == 566 || iEvent.luminosityBlock() == 868 || iEvent.luminosityBlock() == 1033 || (iEvent.luminosityBlock() > 2171 && iEvent.luminosityBlock() < 2369) || iEvent.luminosityBlock() > 2465)
   badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146698) {
   if (iEvent.luminosityBlock() < 155 || (iEvent.luminosityBlock() > 180 && iEvent.luminosityBlock() < 186) || iEvent.luminosityBlock() > 189)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146710) {
   if (iEvent.luminosityBlock() == 116 || (iEvent.luminosityBlock() > 49 && iEvent.luminosityBlock() < 114) || iEvent.luminosityBlock() > 214)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146712) {
   if (iEvent.luminosityBlock() > 69)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146713) {
   if (iEvent.luminosityBlock() == 49 || iEvent.luminosityBlock() > 256)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146715) {
   if (iEvent.luminosityBlock() > 125)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146721) {
   if (iEvent.luminosityBlock() > 6)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146724) {
   if (iEvent.luminosityBlock() == 107 || iEvent.luminosityBlock() == 108 || (iEvent.luminosityBlock() > 109 && iEvent.luminosityBlock() < 112) || iEvent.luminosityBlock() == 151 || iEvent.luminosityBlock() > 159)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146804) {
   if (iEvent.luminosityBlock() < 111 || iEvent.luminosityBlock() == 149 || iEvent.luminosityBlock() == 521 || iEvent.luminosityBlock() == 790 || iEvent.luminosityBlock() == 823 || iEvent.luminosityBlock() > 905)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146807) {
   if (iEvent.luminosityBlock() < 132 || iEvent.luminosityBlock() == 363 || iEvent.luminosityBlock() == 364 || iEvent.luminosityBlock() == 421 || iEvent.luminosityBlock() > 469)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 146944) {
   if (iEvent.luminosityBlock() < 177 || iEvent.luminosityBlock() > 669)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147043) {
   if (iEvent.luminosityBlock() < 161 || iEvent.luminosityBlock() > 500)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147048) {
   if (iEvent.luminosityBlock() < 94 || iEvent.luminosityBlock() > 484)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147114) {
   if (iEvent.luminosityBlock() < 180 || (iEvent.luminosityBlock() > 187 && iEvent.luminosityBlock() < 227) || (iEvent.luminosityBlock() > 240 && iEvent.luminosityBlock() < 247) || iEvent.luminosityBlock() > 667)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147115) {
   if (iEvent.luminosityBlock() > 546)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147116) {
   if (iEvent.luminosityBlock() > 54)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147196) {
   if (iEvent.luminosityBlock() > 90)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147214) {
   if (iEvent.luminosityBlock() > 79)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147216) {
   if (iEvent.luminosityBlock() > 63)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147217) {
   if (iEvent.luminosityBlock() > 193)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147218) {
   if (iEvent.luminosityBlock() > 45)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147219) {
   if ((iEvent.luminosityBlock() > 293 && iEvent.luminosityBlock() < 309) || iEvent.luminosityBlock() > 320)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147222) {
   if (iEvent.luminosityBlock() > 444)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147284) {
   if (iEvent.luminosityBlock() < 32 || iEvent.luminosityBlock() > 306)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147390) {
   if (iEvent.luminosityBlock() == 479 || iEvent.luminosityBlock() > 837)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147450) {
   if (iEvent.luminosityBlock() < 80 || iEvent.luminosityBlock() > 166)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147451) {
   if (iEvent.luminosityBlock() == 117 || iEvent.luminosityBlock() > 129)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147452) {
   if (iEvent.luminosityBlock() > 44)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147453) {
   if (iEvent.luminosityBlock() > 146)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147454) {
   if (iEvent.luminosityBlock() > 97)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147754) {
   if (iEvent.luminosityBlock() == 168 || iEvent.luminosityBlock() == 169 || iEvent.luminosityBlock() > 377)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147755) {
   if (iEvent.luminosityBlock() < 81 || iEvent.luminosityBlock() > 231)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147757) {
   if (iEvent.luminosityBlock() > 359)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147926) {
   if (iEvent.luminosityBlock() < 77 || iEvent.luminosityBlock() > 548)
   badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147927) {
   if (iEvent.luminosityBlock() > 152)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 147929) {
   if ((iEvent.luminosityBlock() > 266 && iEvent.luminosityBlock() < 272) || iEvent.luminosityBlock() == 619 || iEvent.luminosityBlock() > 643)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148002) {
   if (iEvent.luminosityBlock() < 92 || iEvent.luminosityBlock() > 203)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148029) {
   if (iEvent.luminosityBlock() < 50 || iEvent.luminosityBlock() == 484 || iEvent.luminosityBlock() == 570 || iEvent.luminosityBlock() > 571)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148031) {
   if ((iEvent.luminosityBlock() > 341 && iEvent.luminosityBlock() < 472) || iEvent.luminosityBlock() == 758 || iEvent.luminosityBlock() > 855)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148032) {
  if (iEvent.luminosityBlock() > 199)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148058) {
   if (iEvent.luminosityBlock() > 97)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148822) {
   if (iEvent.luminosityBlock() > 446)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148829) {
   if ((iEvent.luminosityBlock() > 240 && iEvent.luminosityBlock() < 244) || iEvent.luminosityBlock() == 74 || iEvent.luminosityBlock() > 303)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148860) {
   if (iEvent.luminosityBlock() > 39)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148862) {
   if (iEvent.luminosityBlock() == 19 || iEvent.luminosityBlock() == 109 || iEvent.luminosityBlock() == 150 || (iEvent.luminosityBlock() > 165 && iEvent.luminosityBlock() < 224) || (iEvent.luminosityBlock() > 258 && iEvent.luminosityBlock() < 262) || iEvent.luminosityBlock() == 298 || iEvent.luminosityBlock() == 367 || (iEvent.luminosityBlock() > 504 && iEvent.luminosityBlock() < 512) || iEvent.luminosityBlock() > 679)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148864) {
   if (iEvent.luminosityBlock() == 32 || (iEvent.luminosityBlock() > 141 && iEvent.luminosityBlock() < 224) || iEvent.luminosityBlock() == 237 || iEvent.luminosityBlock() == 477 || iEvent.luminosityBlock() > 680)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148952) {
   if (iEvent.luminosityBlock() < 70 || iEvent.luminosityBlock() > 257)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 148953) {
   if (iEvent.luminosityBlock() > 100)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149003) {
   if (iEvent.luminosityBlock() < 84 || iEvent.luminosityBlock() > 238)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149011) {
   if (iEvent.luminosityBlock() == 342 || iEvent.luminosityBlock() > 706)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149058) {
   if (iEvent.luminosityBlock() > 65)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149063) {
   if (iEvent.luminosityBlock() > 102)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149181) {
   if (iEvent.luminosityBlock() < 229 || (iEvent.luminosityBlock() > 1840 && iEvent.luminosityBlock() < 1844) || iEvent.luminosityBlock() > 1920)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149291) {
   if (iEvent.luminosityBlock() < 79 || (iEvent.luminosityBlock() > 79 && iEvent.luminosityBlock() < 82) || iEvent.luminosityBlock() == 787 || iEvent.luminosityBlock() == 789 || (iEvent.luminosityBlock() > 790 && iEvent.luminosityBlock() < 794) || iEvent.luminosityBlock() > 794)
    badJSON = iEvent.run(); 
 }
 else if (iEvent.run() == 149294) {
  if (iEvent.luminosityBlock() > 171)
    badJSON = iEvent.run(); 
 }
 else {
   badJSON = iEvent.run(); 
 }

// signal presence of bad JSON event
if (badJSON > 0) {
  LogInfo("Demo")<<"bad JSON Event id"<<iEvent.id();
  h201->Fill(iEvent.run()); 

  // find out how to exit here ...: 'continue'
 }
else {
  h204->Fill(iEvent.run());
 }

   // LogInfo("Demo")<<"Event number"<<(iEvent.id()).event()<<" Run number"<<iEvent.run()<<"  Lumi:"<<iEvent.luminosityBlock();


 //                 event is to be kept                      //
 //                 load relevant event information          //

 iEvent.getByLabel("muons", muons);
 iEvent.getByLabel("globalMuons", gmuons);
 iEvent.getByLabel("generalTracks", tracks); 
 iEvent.getByLabel("offlineBeamSpot", beamSpotHandle);
 iEvent.getByLabel("gsfElectrons",electrons);
 iEvent.getByLabel("pfMet",pfmets);
 iEvent.getByLabel("met",calomets);
 iEvent.getByLabel("corMetGlobalMuons",muCorrmets);

  h133-> Fill((pfmets->front()).et());
 h134-> Fill((calomets->front()).et());
 h135-> Fill((muCorrmets->front()).et());
 reco::BeamSpot beamSpot;
 if ( beamSpotHandle.isValid() )
{
    beamSpot = *beamSpotHandle;

} else
{
    edm::LogInfo("Demo")
      << "No beam spot available from EventSetup \n";
}

 // choose primary verices with/without beam spot
 
 iEvent.getByLabel("offlinePrimaryVerticesWithBS",Primvertex);
 //iEvent.getByLabel("offlinePrimaryVertices",Primvertex);
 
 // fill basic track information (all tracks in event)

 h6->Fill(tracks->size());
 h26->Fill(Primvertex->size());

 // loop over tracks

  for( reco::TrackCollection::const_iterator it = tracks->begin(); it !=
 tracks->end(); it++) {
    // LogInfo("Demo")<<"track p"<<it->p()<< "  track reference position"<<it->referencePoint()<< "   track vertex position"<<it->vertex();
    h34->Fill(it->p());
    h35->Fill(it->pt());
    h38->Fill(it->eta());
    h81->Fill(it->phi());
  

   // h23->Fill(it->vx());
   //h24->Fill(it->vy());
   // h25->Fill(it->vz());

   // fill histograms for QCD-10-006

   if(fabs(it->eta())<=0.200){
     
     h9->Fill(it->pt());}

if(fabs(it->eta())>0.200 && fabs(it->eta())<0.400){
   
     h10->Fill(it->pt());}
 if(fabs(it->eta())>0.400 && fabs(it->eta())<=0.600){
     
     h11->Fill(it->pt());}
if(fabs(it->eta())<0.600 && fabs(it->eta())<=0.800){
 
     h12->Fill(it->pt());}
if(fabs(it->eta())>0.800 && fabs(it->eta())<=1.00){
  
     h13->Fill(it->pt());}
if(fabs(it->eta())>1.00 && fabs(it->eta())<=1.20){
   
     h14->Fill(it->pt());}
if(fabs(it->eta())>1.200 && fabs(it->eta())<=1.40){
                                      
     h15->Fill(it->pt());}
if(fabs(it->eta())>1.400 && fabs(it->eta())<=1.60){
    
     h16->Fill(it->pt());}
if(fabs(it->eta())>1.600 && fabs(it->eta())<=1.80){
  
     h17->Fill(it->pt());}
if(fabs(it->eta())>1.800 && fabs(it->eta())<=2.00){
  
     h18->Fill(it->pt());}
if(fabs(it->eta())>2.000 && fabs(it->eta())<=2.20){

     h19->Fill(it->pt());}
if(fabs(it->eta())>2.200 && fabs(it->eta())<=2.40){
    
     h20->Fill(it->pt());}
if(fabs(it->eta())>2.400 && fabs(it->eta())<=2.60){

     h21->Fill(it->pt());}

  }//end of track collection loop


  // fill basic vertex information

  int size; // variable to store the size of vertices in an event
  size=Primvertex->size();

  // loop over primary vertices

  for(reco::VertexCollection::const_iterator ite = Primvertex->begin(); ite !=Primvertex->end(); ite++) {
    
  int Muflag=0; //  flag indicating whether a muon candidate is associated to this vertex

  // store z position of first vertex 
  if(ite== Primvertex->begin())firstz=ite->z();
  
  // loop over muon collection to check for muon tracks associated to this vertex, i.e. track refernce position close to the vertex
  for (MuonCollection::const_iterator itMuon = muons->begin(); itMuon != muons->end(); ++itMuon) {
    if((itMuon->track()).isNonnull()){
if(fabs(ite->x()-(itMuon->track())->vx())<=0.1 && fabs(ite->y()-(itMuon->track())->vy())<=0.1 && fabs(ite->z()-(itMuon->track())->vz())<=1.0)
 Muflag=1; // The vertex has a muon associated to it

    }
  }  // end of loop over muon collection

    if(ite->tracksSize()==0){ //This is done so that there are no vertices with zero tracks stored in the histogram.
      size=size-1; }

    /// store distance of vertex to first vertex
 if(ite->z()!=firstz)
    {
      deltaz=fabs(firstz-(ite->z()));
      h22->Fill(deltaz);
      }

    if(ite->tracksSize()!=0 && Muflag==0)

// only store the coordinates of those vertices which are valid and have tracks && have no muons (= "next-to-miminum bias")
// very first attempt in context of FWD-11-001

      { h36->Fill(ite->x());
        h37->Fill(ite->y());
        h7->Fill(ite->z());
        h87->Fill(ite->tracksSize());

              //-----to get track details for valid vertices-------------//

    //  LogInfo("Demo")<<"Vertex position"<<ite->position()<<endl;

    //  loop over all tracks from this vertex

    int counter=0;   
 for(reco::Vertex::trackRef_iterator iTrack  =ite->tracks_begin(); iTrack != ite->tracks_end();++iTrack) { 
// for dealing with tracks associated with a particular vertex

   // why *iTrack ??
      h27->Fill((*iTrack)->pt()); // vertex.track pt
      h28->Fill((*iTrack)->p()); // vertex.track p
      h85->Fill((*iTrack)->eta());
      h82->Fill((*iTrack)->phi());

      // LogInfo("Demo")<<"Vertex track p"<<(*iTrack)->p()<<"  Vertex trackposition"<<(*iTrack)->referencePoint();

      counter++;
 }
 // fill number of tracks associated to this vertex (is it Ok to fill int?)
 h86->Fill(counter);
    

      }// end of if(ite->tracksSize()!=0 && Muflag==0)
  }//end of vertex collection loop

  
  h8->Fill(size); //only valid vertices get stored.
 

   //------------------analysing global muons with the track collection-------------------------// 


   h4->Fill(gmuons->size());
  
  
  for( reco::TrackCollection::const_iterator it= gmuons->begin(); it !=gmuons->end(); it++) {
   
   h1->Fill(it->p());
   h2->Fill(it->pt());
   h3->Fill(it->eta());
   h53->Fill(it->chi2());
   h54->Fill(it->ndof());
   h55->Fill(it->normalizedChi2());
   h83->Fill(it->phi());
 // LogInfo("Demo")  <<"global  muon track pointer "<<it;
   // LogInfo("Demo")<<"global muon track p"<<it->p()<<"  global muon track pos"<<it->referencePoint()<<" global muon track vertex"<<it->vertex();

       //-----------------now prepare quality cuts---------------------//
   
   int size1=0;
   int ValidHits=0, PixelHits=0;
       const reco::HitPattern& p = it->hitPattern();
      
       // loop over the hits of the track
       for (int i=0; i<p.numberOfHits(); i++) {
	 uint32_t hit = p.getHitPattern(i);
	 
	 // if the hit is valid and in pixel 
	 if (p.validHitFilter(hit) && p.pixelHitFilter(hit)) PixelHits++;
	 
	 if (p.validHitFilter(hit))ValidHits++;
	 
       }
       if(ValidHits>=10 && PixelHits>=1) size1++; // For Mu sample
	 
	   
       if(size1)h59->Fill(size1);// Fill hitsOK histo
       h60->Fill(ValidHits);
       h61->Fill(PixelHits);

      
       // loop over muons satisfying quality cuts //
       // as applied for plots used in presentation at CMS physics meetring //

       if(gmuons->size()>=2 && ValidHits>=12 && PixelHits>=2 && it->normalizedChi2()<4.0)
	 //       if(gmuons->size()>=2)
     {

       reco::TrackCollection::const_iterator i=it;
       i++;
       for(;i!=gmuons->end();i++){
	 
	 int ValidHits1=0, PixelHits1=0;
	 const reco::HitPattern& p1 = i->hitPattern();
	
       // loop over the hits of the track
	 for (int n=0; n<p1.numberOfHits(); n++) {
	 uint32_t hit = p1.getHitPattern(n);

	 // if the hit is valid and in pixel 
	 if (p1.validHitFilter(hit) && p1.pixelHitFilter(hit)) PixelHits1++;
	 
	 if (p1.validHitFilter(hit))ValidHits1++;
	 
	 }
	 

	 if(it->charge()==-(i->charge())) // unlike charges
	 {
	   //----------to calculate invariant mass-----------------//

	   s1=sqrt(((it->p())*(it->p())+sqm1)*((i->p())*(i->p())+sqm1));
	   s2=it->px()*i->px()+it->py()*i->py()+it->pz()*i->pz();
	   s=sqrt(2.0*(sqm1+(s1-s2)));
	   h5->Fill(s);
	   h44->Fill(s);
	   h80->Fill(s);
	   // apply weight 200/(ln10*m/GeV) to convert to events/GeV (see sheet)
	   w=200/log(10)/s;
	   h100->Fill(log10(s),w);
	   
	   M=invMass(it->p(),it->px(),it->py(),it->pz(),i->p(),i->px(),i->py(),i->pz());
	   h210->Fill(M);
	   

           // scorr needs to be fixed ... use average pseudorapidity for approximate correction, should use rapidity

	   scorr=(1.0+0.00038+0.0003*(i->eta()+it->eta())*(i->eta()+it->eta())/4)*s;
		  h66->Fill(scorr);
		  h67->Fill(scorr);

	   //----------to calculate rapidity---------------------//

	     s3=(it->p())*(it->p())+(i->p())*(i->p());
		  s4= sqrt(s3+2*s2+s*s);
		  pz=it->pz()+i->pz();
		  rap=0.5*log((s4+pz)/(s4-pz));
		  if(fabs(rap)<1.2) {h47->Fill(s);h68->Fill(scorr);}
		  else if(fabs(rap)<1.6){ h48->Fill(s);h69->Fill(scorr);}
		  else if(fabs(rap)<2.4){ h49->Fill(s);h70->Fill(scorr);}

		   //--------------------------upsilon ranges ----------------------------------------------------------//
		  
		  if(fabs(it->eta())<2.4 && fabs(i->eta())<2.4){ h77->Fill(s);h79->Fill(scorr);}
		  if(fabs(it->eta())<1. && fabs(i->eta())<1.) {  h76->Fill(s);h78->Fill(scorr);}
	 }

	 if(it->charge()==(i->charge()))   // like charges invariant mass
	 {
	   s1=sqrt(((it->p())*(it->p())+sqm1)*((i->p())*(i->p())+sqm1));
	   s2=it->px()*i->px()+it->py()*i->py()+it->pz()*i->pz();
	   s=sqrt(2.0*(sqm1+(s1-s2)));
	   h46->Fill(s);
	   w=200/log(10)/s;
	   h102->Fill(log10(s),w);
	  
	 }
	 

       }//end of for(;i!=gmuons....)

     }//end of if(gmuons>=2.....)
  }//end of reco ::TrackCollection
  


  //--------------------------analysing muons with MuonCollection----------------------------------------//
  //                          for J/psi (BPH-10-002) and Z (EWK-10-002)                                  //
 
 
  h33->Fill(muons->size()); // only the total number of muons
 
for (MuonCollection::const_iterator itMuon = muons->begin(); itMuon != muons->end(); ++itMuon) {

  double Mt;
 int  ValidHits=0; int PixelHits=0;//TM_J/Psi
 int  GM_ValidHits=0; int GM_PixelHits=0;//GM_Z
 int size2=0;
 int jpsi_flag1=0;
 
 int Zflag1=0;
 
 int Wflag1=0;
 int Wflag2=1;
 int goodhit=0;//GM_Z Muon Chamber hits
 double relIso=1.;// relative Isolation for muons(Z paper);


 math::XYZPoint point(beamSpot.position());

  // LogInfo("Demo")  <<" muon p "<<itMuon->momentum()<<" p "<<itMuon->p()<<" pt "<<itMuon->pt();
  // LogInfo("Demo") <<" global "<<itMuon->isGlobalMuon()<<" tracker "<<itMuon->isTrackerMuon();

  h29->Fill(itMuon->p());h30->Fill(itMuon->pt());h31->Fill(itMuon->eta());  h84->Fill(itMuon->phi());
  
 
  if((itMuon->track()).isNonnull()){// some muons might not have valid track references

      h56->Fill(((itMuon->track()))->chi2());
      h57->Fill(((itMuon->track()))->ndof());
      h58->Fill(((itMuon->track()))->normalizedChi2());
    
// LogInfo("Demo")  <<" muon track p "<<(itMuon->track())->p()<<"  muon track position"<<(itMuon->track())->referencePoint()<<"  Muon Vertex Position"<<itMuon->vertex();


	  //-----------------------------------------------------------------//
       //-----------------now putting the cuts for j/psi---------------------//
	  //--------------------------------------------------------------//

	  const reco::HitPattern& p = (itMuon->track())->hitPattern();
	  

       // loop over the hits of the track
       for (int i=0; i<p.numberOfHits(); i++) {
	 uint32_t hit = p.getHitPattern(i);
	  
	
	 // if the hit is valid and in pixel
	 if (p.validHitFilter(hit) && p.pixelHitFilter(hit)){
	   PixelHits++;
           }
	 if (p.validHitFilter(hit)){
	   ValidHits++;
	 }
       }
       if(ValidHits>=12 && PixelHits>=2){
	 size2++; }
       h63->Fill(ValidHits);
       h64->Fill(PixelHits);
       if(size2)h62->Fill(size2);// Fill hitsOK histo


	if (ValidHits>=12 && PixelHits>=2 && (itMuon->track())->normalizedChi2()<4.0 && muon::isGoodMuon(*itMuon,muon::TMLastStationAngTight) && muon::isGoodMuon(*itMuon,muon::TrackerMuonArbitrated) && itMuon->isTrackerMuon())
   {
     if(fabs(itMuon->eta())<1.3 && itMuon->pt()>3.3)jpsi_flag1=1;
     else if(fabs(itMuon->eta())>1.3 && fabs(itMuon->eta())<2.2 && itMuon->p()>2.9)jpsi_flag1=1;
     else if(fabs(itMuon->eta())>2.2  && fabs(itMuon->eta())<2.4 && itMuon->pt()>0.8)jpsi_flag1=1;
   }
 



		//--------------------------------------------------------------------------------//
		//----------------------------Z & W cuts----------------------------------------------//
		//--------------------------------------------------------------------------------//

       if(itMuon->isGlobalMuon() && (itMuon->globalTrack()).isNonnull())
	 {
	   //relative isolation
	  relIso=((itMuon->isolationR03()).sumPt+(itMuon->isolationR03()).emEt+(itMuon->isolationR03()).hadEt)/itMuon->pt();



	  // checking hit pattern info
	  const reco::HitPattern& GM_p = (itMuon->globalTrack())->hitPattern();
	  goodhit=GM_p.numberOfValidMuonHits();
	  for (int i=0; i<GM_p.numberOfHits(); i++) {
	  uint32_t hit = GM_p.getHitPattern(i); 
	 // if the hit is valid and in pixel
	 if (GM_p.validHitFilter(hit) && GM_p.pixelHitFilter(hit)){
	   GM_PixelHits++;
           }
	 if (GM_p.validHitFilter(hit)){
	   GM_ValidHits++; 
	  }
	  }// for (int i=0; i<GM_p.numberOfHits(); i++) ends
           h92->Fill(goodhit);


	   bool result= muon::isGoodMuon(*itMuon, muon::TMLastStationTight);
           h93->Fill(result);
	   h91->Fill((itMuon->globalTrack())->dxy(point)); // Transverse impact parameter w.r.t. BeamSpot


	   if(GM_ValidHits>=10 && GM_PixelHits>=1 && goodhit>=1 && (itMuon->globalTrack())->normalizedChi2()<10.0 && fabs((itMuon->globalTrack())->dxy(point))<0.2 && result && relIso<0.15)
	     {
	       if(itMuon->pt()>20 && fabs(itMuon->eta())<2.1)
		 {
		   Zflag1=1;
		   Wflag1=1;
		 }
	      
	     }
	 }//if(itMuon->isGlobalMuon()..........) ends

      }//isNonnull() ends
 
     

 
  //--------------------------look for dimuons----------------------------------------------------------------------------//
  //------------------------------------------------------------------------------------------------------//
  if(muons->size()>=2)
    {
      
      if(itMuon->isTrackerMuon())
	{
	  //---------------only for tracker muons--------------//
          //   fill for first muon of multimuon candidate      //
          //   *** logic to be reconsidered ***  //        

  h50->Fill(((itMuon->track()))->chi2());
  h51->Fill(((itMuon->track()))->ndof());
  h52->Fill(((itMuon->track()))->normalizedChi2());
	}

  //----------------------------------2nd tracker muon loop ---------------------------------------------//

//-------------------------------------------------------------------//
	  MuonCollection::const_iterator itM=itMuon;
	  itM++;

	  for(;itM!=muons->end();itM++)
	    {
	     int jpsi_flag2=0;
	     int Zflag2=0;
	     Wflag2=1;// to reject events with 2 muons
	     int goodhit1=0;//GM_Z Muon Chamber hits
	     double relIso1=1.0;// relative Isolation for muons(Z paper);
	      if((itM->track()).isNonnull() && (itMuon->track()).isNonnull()){ 
		
 
		h88->Fill(fabs((itMuon->track())->vx()-(itM->track())->vx()));// for j_psi
		h89->Fill(fabs((itMuon->track())->vy()-(itM->track())->vy()));//for j_psi
		h90->Fill(fabs((itMuon->track())->vz()-(itM->track())->vz()));//for_j/psi
		int ValidHits1=0, PixelHits1=0;
		int GM_ValidHits1=0, GM_PixelHits1=0;
		double dx,dy,dz;
		dx=(itMuon->track())->vx()-(itM->track())->vx();// for j_psi
		dy=(itMuon->track())->vy()-(itM->track())->vy();// for j_psi
		dz=(itMuon->track())->vz()-(itM->track())->vz();// for j_psi


		const reco::HitPattern& p1 = (itM->track())->hitPattern();
	 
		// loop over the hits of the track
		for (int n=0; n<p1.numberOfHits(); n++) {
		  uint32_t hit = p1.getHitPattern(n);

		  // if the hit is valid and in pixel 
		  if (p1.validHitFilter(hit) && p1.pixelHitFilter(hit)) PixelHits1++;
	 
		  if (p1.validHitFilter(hit))ValidHits1++;
		  
		}


		// for W 
        
		if(itM->isGlobalMuon() &&(itM->globalTrack()).isNonnull()){
		  if(itM->pt()>10.0) Wflag2=0;// to reject events for W mass


		  //for  Z
		  relIso1=((itM->isolationR03()).sumPt+(itM->isolationR03()).emEt+(itM->isolationR03()).hadEt)/itM->pt();
		  bool result1= muon::isGoodMuon(*itMuon, muon::TMLastStationTight);
		  const reco::HitPattern& GM_p1 = (itM->globalTrack())->hitPattern();
		  goodhit1=GM_p1.numberOfValidMuonHits();
		  for (int n=0; n<GM_p1.numberOfHits(); n++) {
		    uint32_t hit = GM_p1.getHitPattern(n);
		     
		    // if the hit is valid and in pixel 
		    if (GM_p1.validHitFilter(hit) && GM_p1.pixelHitFilter(hit)) GM_PixelHits1++;
	 
		    if (GM_p1.validHitFilter(hit))GM_ValidHits1++;
	 
		  }


		  if( GM_ValidHits1>=10 && GM_PixelHits1>=1 && goodhit1>=1 && (itM->globalTrack())->normalizedChi2()<10.0 && fabs((itM->globalTrack())->dxy(point))<0.2 && result1 && relIso1<0.15)
		    {
		      if(itM->pt()>20 && fabs(itM->eta())<2.1) Zflag2=1;
		      
		    }


		}// if(itM->isGlobalMuon().....) ends





     // for j_psi
       if (ValidHits1>=12 && PixelHits1>=2 && (itM->track())->normalizedChi2()<4.0 && dx<=0.1 && dy<=0.1 && dz<=0.3 && muon::isGoodMuon(*itM,muon::TMLastStationAngTight) && muon::isGoodMuon(*itM,muon::TrackerMuonArbitrated) && itM->isTrackerMuon())
	 {
	    if(fabs(itM->eta())<1.3 && itM->pt()>3.3)jpsi_flag2=1;
	    else if(fabs(itM->eta())>1.3 && fabs(itM->eta())<2.2 && itM->p()>2.9)jpsi_flag2=1;
	    else if(fabs(itM->eta())>2.2 && fabs(itM->eta())<2.4 && itM->pt()>0.8)jpsi_flag2=1;
	 }
	      }//isNonnull() ends
       if(itM->charge()==-itMuon->charge() )// unlike charges
		{
		  
		  //------------invariant mass------------------------------//

		  s1=sqrt(((itMuon->p())*(itMuon->p())+sqm1)*((itM->p())*(itM->p())+sqm1));
		  s2=itMuon->px()*itM->px()+itMuon->py()*itM->py()+itMuon->pz()*itM->pz();
		  s=sqrt(2.0*(sqm1+(s1-s2)));
		 
		  scorr=(1.0+0.00038+0.0003*(itM->eta()+itMuon->eta())*(itM->eta()+itMuon->eta())/4)*s;
		  w=200/log(10)/s;
		  h101->Fill(log10(s),w);
		  if(jpsi_flag2==1 && jpsi_flag1==1){//fill the jpsi hists only if these criteria are fulfilled
		  h32->Fill(s);
		  h65->Fill(scorr);
		  }//end of if(jpsi_flag2)
		  if(Zflag1==1 && Zflag2==1)// fill only if  z flags are fine
		    {
		      h94->Fill(s);
		      
		    }

		  //------------------rapidity------------------------------//

		  s3=(itMuon->p())*(itMuon->p())+(itM->p())*(itM->p());
		  s4= sqrt(s3+2*s2+s*s);
		  pz=itM->pz()+itMuon->pz();
		  rap=0.5*log((s4+pz)/(s4-pz));

		   if(jpsi_flag2 && jpsi_flag1){//fill the jpsi hists only if these criteria are fulfilled
		  if(fabs(rap)<1.2){ h39->Fill(s); h73->Fill(scorr);}
		  else if(fabs(rap)<1.6){ h40->Fill(s);h74->Fill(scorr);}
		  else if(fabs(rap)<2.4){ h41->Fill(s);h75->Fill(scorr);}


		   }


		   //-------------------------------Acceptance histogram----------------------------------------------//

		    if (abs(s-jpsim)<100){
		      h_Py->Fill(rap,sqrt( pow(itMuon->pt(),2) + pow(itM->pt(),2)  );
		   
		   	}
			// cout<<" P_t1= " << itMuon->pt()<< "   P_t2=" << itM->pt() <<"\n";

		  //--------------------------upsilon ranges ----------------------------------------------------------//
		  
		  if(fabs(itM->eta())<2.4 && fabs(itMuon->eta())<2.4){ h43->Fill(s);h72->Fill(scorr);}
		  if(fabs(itM->eta())<1. && fabs(itMuon->eta())<1.) {  h42->Fill(s);h71->Fill(scorr);}
		}

       if(itM->charge()==itMuon->charge() )// like charges invariant mass
		{
		  s1=sqrt(((itMuon->p())*(itMuon->p())+sqm1)*((itM->p())*(itM->p())+sqm1));
		  s2=itMuon->px()*itM->px()+itMuon->py()*itM->py()+itMuon->pz()*itM->pz();
		  s=sqrt(2.0*(sqm1+(s1-s2)));
		  
		  w=200/log(10)/s;
		  h103->Fill(log10(s),w);
		  if(jpsi_flag2 && jpsi_flag1){// only if the jpsi cuts are fulfilled
		    h45->Fill(s);
		    h82->Fill(s);
		  }
		  if(Zflag1==1 && Zflag2==1)//only if Z cuts are satisfied
		    {
		      
		      h95->Fill(s);
		      
		    }
		}
	    }//for(;itM!=muons;...)
	  	 
  
    }//(muons->size()>=2) ends
  	  //-------------------------------------------W Block--------------------------------------------------------------------//
    Mt=sqrt(2.0*(itMuon->pt())*((pfmets->front()).pt())*(1.0-cos((itMuon->phi())-((pfmets->front()).phi()))));
    h129->Fill(Mt);
	  if(Wflag1==1 && Wflag2==1)
	    {
	      h130->Fill(Mt);
	      h137->Fill((pfmets->front()).pt());
	    }

 }// Muon Collection for loop ends


/*------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------ELECTRON COLLECTION--------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------*/






h105->Fill(electrons->size());
 for( reco::GsfElectronCollection::const_iterator it = electrons->begin(); it !=
 electrons->end(); it++) {
   int Z_ElecFlag1=0;
   int W_ElecFlag1=0;
    int Z_ElecFlag2=0;
    int W_ElecFlag2=1;
   
   double Mt;
   int misshits, misshits1;
   h96->Fill(it->p());
    h97->Fill(it->pt());
    h98->Fill(it->eta());
    h99->Fill(it->phi());
    h106->Fill(fabs((it->superCluster())->eta()));
    h118->Fill((it->et()));
    h107->Fill(fabs((it->superCluster())->rawEnergy()));
    if(it->isEB()){
    
      h108->Fill(it->dr03TkSumPt()/(it->pt()));//for electron, pt and et are nearly the same.
      h109->Fill(it->dr03EcalRecHitSumEt()/(it->pt()));
      h110->Fill(it->dr03HcalTowerSumEt()/(it->pt()));
    }
    if(it->isEE()){
   
      h120->Fill(it->dr03TkSumPt()/(it->pt()));
      h121->Fill(it->dr03EcalRecHitSumEt()/(it->pt()));
      h122->Fill(it->dr03HcalTowerSumEt()/(it->pt()));
    }
    misshits=((it->gsfTrack())->trackerExpectedHitsInner()).numberOfHits();
    h111->Fill(misshits); // number of missing hits
    h113->Fill(it->convDist());
    h112->Fill(it->convDcot());

    if(it->isEB()){
    h114->Fill(it->sigmaIetaIeta());
    h115->Fill(it->deltaPhiSuperClusterTrackAtVtx());
    h116->Fill(it->deltaEtaSuperClusterTrackAtVtx());
    h117->Fill(it->hcalOverEcal());
    }
    if(it->isEE()){
    h123->Fill(it->sigmaIetaIeta());
    h124->Fill(it->deltaPhiSuperClusterTrackAtVtx());
    h125->Fill(it->deltaEtaSuperClusterTrackAtVtx());
    h126->Fill(it->hcalOverEcal());
    }
    
    //checking if the electron superCluster is within ECAL acceptance
   
    if(((fabs((it->superCluster())->eta()))<1.4442) ||( (fabs((it->superCluster())->eta()))<2.5 && (fabs((it->superCluster())->eta()))>1.5666))
 {
       
	if(it->et()>20.)

	  {
	    //starting with WP80 cuts!!!

	    if(it->isEB())//for barrel
	      {
		if((it->dr03TkSumPt()/(it->pt()))<0.09 && (it->dr03EcalRecHitSumEt()/(it->pt()))<0.07 && (it->dr03HcalTowerSumEt()/(it->pt()))<0.10 && misshits<1 && it->convDist()<0.02 && it->convDcot()<0.02)
		  {
		    if(it->sigmaIetaIeta()<0.01 && fabs(it->deltaPhiSuperClusterTrackAtVtx())<0.06 && fabs(it->deltaEtaSuperClusterTrackAtVtx())<0.004 && it->hcalOverEcal()<0.04)
		      { Z_ElecFlag1=1;
			W_ElecFlag1=1;
			
		      }
		    
		  }
	      }
	    else if(it->isEE())//for endcap
	      {
		if((it->dr03TkSumPt()/(it->pt()))<0.04 && (it->dr03EcalRecHitSumEt()/(it->pt()))<0.05 && (it->dr03HcalTowerSumEt()/(it->pt()))<0.025 && misshits<1 && it->convDist()<0.02 && it->convDcot()<0.02)
		  {
		    if(it->sigmaIetaIeta()<0.03 && fabs(it->deltaPhiSuperClusterTrackAtVtx())<0.03 && it->hcalOverEcal()<0.025)
		      { Z_ElecFlag1=1;
			W_ElecFlag1=1;
			
		      }
		  }	
	      }
	  }//	if(it->et()>20) ends

	  
      }//if(((fabs(it->superCluster())->eta())<1.4442) ||( (fabs(it->superCluster())->eta())<2.5 && (fabs(it->superCluster())->eta())>1.5666)) ends

    if(electrons->size()>=2){
    GsfElectronCollection::const_iterator ite=it;
     ite++;
    
    
      for(;ite!=electrons->end();ite++)
	{
	   Z_ElecFlag2=0;
	   W_ElecFlag2=1;// to reject events with a second electron satisfying some loose criteria
	  misshits1=((ite->gsfTrack())->trackerExpectedHitsInner()).numberOfHits();
	  if((fabs((ite->superCluster())->eta())<1.4442) ||( fabs((ite->superCluster())->eta())<2.5 && fabs((ite->superCluster())->eta())>1.5666))
	 
      {
	
	if(ite->et()>20)
	  { 
	   
	  //--------------------------------------------------------Z block------------------------------------------------------------------------------//
	  //starting with WP80 cuts!!!

	    if( Z_ElecFlag1==1)
	      {// to check for the 2nd electron only if the 1st flag is true
		
	    if(ite->isEB() )
	      {
		if((ite->dr03TkSumPt()/(ite->pt()))<0.09 && (ite->dr03EcalRecHitSumEt()/(ite->pt()))<0.07 && (ite->dr03HcalTowerSumEt()/(ite->pt()))<0.10 && misshits1<1 && ite->convDist()<0.02 && ite->convDcot()<0.02)
		  {
		    
		    if(ite->sigmaIetaIeta()<0.01 && fabs(ite->deltaPhiSuperClusterTrackAtVtx())<0.06 && fabs(ite->deltaEtaSuperClusterTrackAtVtx())<0.004 && ite->hcalOverEcal()<0.04)
		      {  
			Z_ElecFlag2=1;
			
		      }
		  }
	      }
	    else if(ite->isEE())//for endcap
	      {
		if((ite->dr03TkSumPt()/(ite->pt()))<0.04 && (ite->dr03EcalRecHitSumEt()/(ite->pt()))<0.05 && (ite->dr03HcalTowerSumEt()/(ite->pt()))<0.025 && misshits1<1 && ite->convDist()<0.02 && ite->convDcot()<0.02)
		  {
		   
		    if(ite->sigmaIetaIeta()<0.03 && fabs(ite->deltaPhiSuperClusterTrackAtVtx())<0.03 && ite->hcalOverEcal()<0.025)
		      {
			Z_ElecFlag2=1;
		
		      }
		  }	
	      }
	    } //if( Z_ElecFlag1==1) ends

	    //----------------------------------------------------W block---------------------------------------------------------------------------------//

	    //starting with WP95 cuts
	    
	    //for rejecting events with a second electron, for calculating the W peak
	    if(W_ElecFlag1==1)
	      {// to check for the 2nd electron only if the 1st flag is true

		
	     if(ite->isEB() )
	      {
		if((ite->dr03TkSumPt()/(ite->pt()))<0.15 && (ite->dr03EcalRecHitSumEt()/(ite->pt()))<2.0 && (ite->dr03HcalTowerSumEt()/(ite->pt()))<0.12 && misshits1<2 )
		  {
		    if(ite->sigmaIetaIeta()<0.01  && fabs(ite->deltaEtaSuperClusterTrackAtVtx())<0.007 && ite->hcalOverEcal()<0.15)
		      { W_ElecFlag2=0;
		      }
		  }
	      }
	    else if(ite->isEE())//for endcap
	      {
		if((ite->dr03TkSumPt()/(ite->pt()))<0.08 && (ite->dr03EcalRecHitSumEt()/(ite->pt()))<0.06 && (ite->dr03HcalTowerSumEt()/(ite->pt()))<0.05 && misshits1<2)
		  {
		    if(ite->sigmaIetaIeta()<0.03 && ite->hcalOverEcal()<0.07)
		      { W_ElecFlag2=0;}
		  }	
	      }

	      }//if( W_ElecFlag1==1) ends


	  }//if(ite->et()>20) ends

	  
      }//if(((fabs(ite->superCluster())->eta())<1.4442) ||( (fabs(ite->superCluster())->eta())<2.5 && (fabs(ite->superCluster())->eta())>1.5666))  ends


	  //---------------------------------------------Z  Block----------------------------------------------------------------//
	  if(it->charge()==-ite->charge() )// unlike charges
		{
		  
		  //------------invariant mass------------------------------//

		  s1=sqrt(((ite->p())*(ite->p())+sqm1)*((it->p())*(it->p())+sqm1));
		  s2=it->px()*ite->px()+it->py()*ite->py()+it->pz()*ite->pz();
		  s=sqrt(2.0*(sqm1+(s1-s2)));
		  h104->Fill(s);
		  if(Z_ElecFlag1==1 && Z_ElecFlag2==1){
		    h119->Fill(s);
		    if(s>=85. && s<=95.)
		      {
			h138->Fill(it->convDcot());
			h139->Fill(it->convDist());
		      }
		  }
		  
		}//if((it->charge()==-ite->charge() ) ends


	  if(it->charge()==ite->charge() )// like charges
		{
		  
		  //------------invariant mass------------------------------//

		  s1=sqrt(((ite->p())*(ite->p())+sqm1)*((it->p())*(it->p())+sqm1));
		  s2=it->px()*ite->px()+it->py()*ite->py()+it->pz()*ite->pz();
		  s=sqrt(2.0*(sqm1+(s1-s2)));
		  h127->Fill(s);
		  if(Z_ElecFlag1==1 && Z_ElecFlag2==1)h128->Fill(s);
		}//if((it->charge()==-ite->charge() ) ends
	  

	  
	}//for(;ite!=electrons....)ends
    }//if(electrons->size()>=2) ends


	  //-------------------------------------------W Block--------------------------------------------------------------------//
    Mt=sqrt(2.0*(it->pt())*((pfmets->front()).pt())*(1.0-cos((it->phi())-((pfmets->front()).phi()))));
    h131->Fill(Mt);
	  if(W_ElecFlag1==1 && W_ElecFlag2==1)
	    {
	      h132->Fill(Mt);
	      h136->Fill((pfmets->front()).pt());
	    }

 }//for(reco::GsfElectronCollection........) ends


}//DemoAnalyzer ends
inline double invMass(double p1,double p1x, double p1y, double p1z, double p2, double p2x, double p2y, double p2z)
    {
        s= sqrt( 2.0 * ( sqm1 + ( sqrt( ( sqm1 + p1 * p1 ) * ( sqm1 + p2 * p2 ) ) - ( p1x * p2x + p1y * p2y + p1z * p2z ) ) ) );
	return s; 
    }

// ------------ method called once each job just before starting event loop  ------------
void 
DemoAnalyzer::beginJob()
{

}

// ------------ method called once each job just after ending the event loop  ------------
void 
DemoAnalyzer::endJob() 
{
}

//define this as a plug-in
DEFINE_FWK_MODULE(DemoAnalyzer);





